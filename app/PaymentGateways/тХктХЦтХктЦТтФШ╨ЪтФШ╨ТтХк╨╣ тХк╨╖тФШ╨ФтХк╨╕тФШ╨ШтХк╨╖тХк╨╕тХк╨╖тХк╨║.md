# دليل إدارة بوابات الدفع في النظام

## 1. مقدمة

هذا الدليل يشرح آلية إدارة بوابات الدفع في النظام، بدءًا من تنفيذ البوابات إلى معالجة الاستجابات (callbacks) والتحقق من عمليات الدفع. يهدف هذا الدليل إلى تبسيط عملية إضافة بوابات دفع جديدة وتوحيد طريقة التعامل معها.

## 2. الهيكل العام للنظام

```
app/
  |- Http/
  |   |- Controllers/
  |   |   |- Payment/
  |   |   |   |- PaymentController.php         # معالجة الدفع الأولي
  |   |   |   |- PaymentCallbackController.php # استقبال الـ return URLs
  |   |   |   |- WebhookController.php         # استقبال الـ webhooks
  |- PaymentGateways/                          # فئات البوابات 
  |   |- BaseGateway.php                       # الفئة الأساسية
  |   |- ClickpayGateway.php                     # مثال على بوابة
  |   |-                              # مثال على بوابة
  |- Services/
  |   |- PaymentService.php                    # خدمة مركزية للدفع
```

## 3. خطوات إضافة بوابة دفع جديدة

### أ. إنشاء فئة البوابة

1. **إنشاء ملف جديد** في مجلد `app/PaymentGateways`:
   ```bash
   # مثال: لإضافة بوابة جديدة
   touch app/PaymentGateways/NewGateway.php
   ```

2. **هيكل الفئة العام**:
   ```php
   <?php

   namespace App\PaymentGateways;

   class NewGateway extends BaseGateway
   {
       /**
        * عناوين API الثابتة
        */
       protected $apiEndpoints = [
           'test' => 'https://sandbox.example.com/api',
           'live' => 'https://api.example.com/api',
       ];
       
       /**
        * الحصول على حقول الإعدادات اللازمة في لوحة التحكم
        */
       public function getConfigFields(): array
       {
           return [
               'api_key' => [
                   'name' => 'api_key',
                   'label' => 'مفتاح API',
                   'type' => 'password',
                   'required' => true,
               ],
               // المزيد من الحقول...
           ];
       }
       
       /**
        * معالجة عملية الدفع
        */
       public function processPayment($order): array
       {
           // منطق الاتصال بالبوابة...
           return $this->formatResponse([
               'success' => true,
               'transaction_id' => 'txn_123456',
               'redirect_url' => 'https://example.com/pay/123',
           ]);
       }
       
       /**
        * التحقق من عملية الدفع
        */
       public function verifyPayment(array $data): bool
       {
           // منطق التحقق...
           return true;
       }
       
       /**
        * معالجة webhook من البوابة
        */
       public function handleWebhook(array $data)
       {
           // منطق معالجة الإشعارات...
           return ['success' => true];
       }
   }
   ```

3. **الدوال المطلوبة في كل بوابة**:
   - `getConfigFields()`: تحدد حقول الإعدادات التي تظهر في لوحة التحكم
   - `processPayment()`: تتعامل مع إنشاء طلب دفع جديد
   - `verifyPayment()`: تتحقق من صحة عملية الدفع
   - `handleWebhook()`: تعالج إشعارات Webhook من البوابة

### ب. إضافة البوابة في قاعدة البيانات

أضف سجلاً في جدول `payment_methods` بالمعلومات الأساسية للبوابة:

```php
PaymentMethod::create([
    'name' => 'اسم البوابة',
    'code' => 'new_gateway', // يجب أن يتطابق مع اسم الفئة (بدون Gateway)
    'description' => 'وصف البوابة',
    'is_active' => true,
    'mode' => 'test', // 'test' أو 'live'
    'default_currency' => 'SAR',
    'credentials' => [
        'test' => [
            'api_key' => 'test_api_key',
            // بيانات اعتماد أخرى...
        ],
        'live' => [
            'api_key' => 'live_api_key',
            // بيانات اعتماد أخرى...
        ],
    ],
    'settings' => [
        // إعدادات إضافية خاصة بالبوابة
    ],
]);
```

## 4. إعداد مسارات الدفع والاستجابة

### أ. مسارات عملية الدفع

```php
// في routes/web.php

// 1. مسار بدء عملية الدفع
Route::post('checkout/pay/{order}', [PaymentController::class, 'processPayment'])
    ->name('checkout.pay')
    ->middleware(['auth', 'verified']);

// 2. مسارات الاستجابة من البوابة (Callbacks)
Route::prefix('payment/callback')->name('payment.callback.')->group(function () {
    // مسار النجاح
    Route::get('{gateway}/success', [PaymentCallbackController::class, 'success'])
        ->name('success');
    
    // مسار الإلغاء
    Route::get('{gateway}/cancel', [PaymentCallbackController::class, 'cancel'])
        ->name('cancel');
    
    // بالإضافة لمسارات مخصصة لكل بوابة إذا لزم الأمر
    Route::get('paypal/success', [PaymentCallbackController::class, 'paypalSuccess'])
        ->name('paypal.success');
});

// 3. مسارات استقبال Webhooks
Route::prefix('payment/webhook')->name('payment.webhook.')->middleware('api')->group(function () {
    Route::post('{gateway}', [WebhookController::class, 'handle'])
        ->name('handle')
        ->withoutMiddleware(['csrf']);
    
    // مسارات مخصصة لبعض البوابات
    Route::post('paypal', [WebhookController::class, 'handlePaypal'])
        ->name('paypal')
        ->withoutMiddleware(['csrf']);
});
```

### ب. المسارات المستخدمة في عملية الدفع

عند تنفيذ البوابة، استخدم المسارات التالية في إعدادات الاستجابة:

```php
// في processPayment() بفئة البوابة
$payload = [
    // بيانات الدفع...
    'success_url' => route('payment.callback.success', [
        'gateway' => 'new_gateway',
        'order_id' => $order->id
    ]),
    'cancel_url' => route('payment.callback.cancel', [
        'gateway' => 'new_gateway',
        'order_id' => $order->id
    ]),
    'webhook_url' => route('payment.webhook.handle', [
        'gateway' => 'new_gateway'
    ]),
];
```

## 5. دورة حياة عملية الدفع

### أ. بدء عملية الدفع

```php
// في PaymentController
public function processPayment(Request $request, Order $order)
{
    // 1. التحقق من صلاحية الطلب
    if (!$order->isReadyForPayment()) {
        return redirect()->back()->with('error', 'الطلب غير صالح للدفع');
    }
    
    // 2. الحصول على طريقة الدفع المختارة
    $paymentMethod = PaymentMethod::findOrFail($request->payment_method_id);
    
    // 3. التحقق من تفعيل طريقة الدفع
    if (!$paymentMethod->isActive()) {
        return redirect()->back()->with('error', 'طريقة الدفع غير متاحة');
    }
    
    // 4. إنشاء مثيل لمعالج الدفع
    $gateway = $paymentMethod->createGateway();
    
    // 5. معالجة الدفع
    try {
        $response = $gateway->processPayment($order);
        
        // 6. حفظ معلومات محاولة الدفع
        $paymentAttempt = $order->payment_attempts()->create([
            'payment_method_id' => $paymentMethod->id,
            'transaction_id' => $response['transaction_id'] ?? null,
            'amount' => $order->total,
            'status' => 'pending',
            'response_data' => $response,
        ]);
        
        // 7. إعادة توجيه المستخدم
        if (!empty($response['redirect_url'])) {
            return redirect()->away($response['redirect_url']);
        }
        
        // إذا كان الدفع مباشرًا (بدون إعادة توجيه)
        if ($response['success']) {
            return redirect()->route('checkout.success', ['order' => $order->id]);
        }
        
        return redirect()->route('checkout.failed', ['order' => $order->id])
                        ->with('error', $response['message'] ?? 'فشلت عملية الدفع');
    } catch (\Exception $e) {
        return redirect()->route('checkout.failed', ['order' => $order->id])
                        ->with('error', 'حدث خطأ أثناء معالجة الدفع');
    }
}
```

### ب. معالجة الاستجابة (Callback)

```php
// في PaymentCallbackController
public function success(Request $request, string $gateway)
{
    // 1. استرجاع الطلب
    $order = Order::findOrFail($request->order_id);
    
    // 2. استرجاع طريقة الدفع
    $paymentMethod = PaymentMethod::where('code', $gateway)->firstOrFail();
    
    // 3. إنشاء مثيل لمعالج الدفع
    $gatewayHandler = $paymentMethod->createGateway();
    
    // 4. التحقق من صحة الدفع
    $verificationData = $request->all();
    
    if ($gatewayHandler->verifyPayment($verificationData)) {
        // 5. تحديث حالة الطلب
        $order->update(['status' => 'paid']);
        
        // 6. توجيه المستخدم لصفحة النجاح
        return redirect()->route('checkout.success', ['order' => $order->id]);
    }
    
    // في حالة الفشل
    return redirect()->route('checkout.failed', ['order' => $order->id])
                    ->with('error', 'فشل التحقق من الدفع');
}
```

### ج. معالجة Webhook

```php
// في WebhookController
public function handle(Request $request, string $gateway)
{
    // 1. استرجاع طريقة الدفع
    $paymentMethod = PaymentMethod::where('code', $gateway)->first();
    
    if (!$paymentMethod) {
        return response()->json(['error' => 'بوابة دفع غير معروفة'], 404);
    }
    
    // 2. إنشاء مثيل لمعالج الدفع
    $gatewayHandler = $paymentMethod->createGateway();
    
    // 3. معالجة الـ webhook
    try {
        $response = $gatewayHandler->handleWebhook($request->all());
        
        // 4. تسجيل الاستجابة (اختياري)
        \Log::info("Webhook received for {$gateway}", [
            'data' => $request->all(),
            'response' => $response
        ]);
        
        return response()->json(['success' => true]);
    } catch (\Exception $e) {
        \Log::error("Webhook error for {$gateway}: " . $e->getMessage());
        
        return response()->json(['error' => $e->getMessage()], 500);
    }
}
```

## 6. مثال توضيحي لتنفيذ بوابة MyFatoorah

### أ. فئة البوابة

```php
<?php

namespace App\PaymentGateways;

use App\Models\Order;
use GuzzleHttp\Client;

class MyFatoorahGateway extends BaseGateway
{
    protected $apiEndpoints = [
        'test' => 'https://apitest.myfatoorah.com',
        'live' => 'https://api.myfatoorah.com',
    ];
    
    public function getConfigFields(): array
    {
        return [
            'test_api_key' => [
                'name' => 'test_api_key',
                'label' => 'مفتاح API للاختبار',
                'type' => 'password',
                'required' => true,
                'mode' => 'test',
            ],
            'live_api_key' => [
                'name' => 'live_api_key',
                'label' => 'مفتاح API للإنتاج',
                'type' => 'password',
                'required' => true,
                'mode' => 'live',
            ],
            // حقول أخرى...
        ];
    }
    
    protected function getApiKey(): string
    {
        return $this->credentials['api_key'] ?? '';
    }
    
    public function processPayment($order): array
    {
        $client = new Client();
        $endpoint = $this->apiEndpoints[$this->mode] . '/v2/SendPayment';
        
        $callbackUrl = route('payment.callback.myfatoorah.success', ['order_id' => $order->id]);
        $errorUrl = route('payment.callback.myfatoorah.cancel', ['order_id' => $order->id]);
        
        $payload = [
            'CustomerName' => $order->customer_name,
            'DisplayCurrencyIso' => $this->settings['currency'] ?? 'SAR',
            'InvoiceValue' => $order->total,
            'CallBackUrl' => $callbackUrl,
            'ErrorUrl' => $errorUrl,
            'MobileCountryCode' => '966',
            'CustomerMobile' => $order->customer_phone,
            'CustomerEmail' => $order->customer_email,
            'Language' => app()->getLocale() == 'ar' ? 'ar' : 'en',
            'InvoiceItems' => [
                // تفاصيل الفاتورة...
            ]
        ];
        
        try {
            $response = $client->post($endpoint, [
                'headers' => [
                    'Authorization' => 'Bearer ' . $this->getApiKey(),
                    'Content-Type' => 'application/json',
                ],
                'json' => $payload,
            ]);
            
            $result = json_decode($response->getBody(), true);
            
            if (isset($result['IsSuccess']) && $result['IsSuccess']) {
                return $this->formatResponse([
                    'success' => true,
                    'transaction_id' => $result['Data']['InvoiceId'],
                    'redirect_url' => $result['Data']['PaymentURL'],
                    'message' => 'تم إنشاء الفاتورة بنجاح',
                    'raw_response' => $result,
                ]);
            }
            
            return $this->formatResponse([
                'success' => false,
                'message' => $result['Message'] ?? 'خطأ غير معروف',
                'raw_response' => $result,
            ]);
        } catch (\Exception $e) {
            return $this->formatResponse([
                'success' => false,
                'message' => $e->getMessage(),
            ]);
        }
    }
    
    public function verifyPayment(array $data): bool
    {
        $paymentId = $data['paymentId'] ?? null;
        
        if (!$paymentId) {
            return false;
        }
        
        $client = new Client();
        $endpoint = $this->apiEndpoints[$this->mode] . '/v2/GetPaymentStatus';
        
        try {
            $response = $client->post($endpoint, [
                'headers' => [
                    'Authorization' => 'Bearer ' . $this->getApiKey(),
                    'Content-Type' => 'application/json',
                ],
                'json' => [
                    'Key' => $paymentId,
                    'KeyType' => 'PaymentId',
                ],
            ]);
            
            $result = json_decode($response->getBody(), true);
            
            if (isset($result['IsSuccess']) && $result['IsSuccess']) {
                $invoiceStatus = $result['Data']['InvoiceStatus'] ?? '';
                return $invoiceStatus === 'Paid';
            }
            
            return false;
        } catch (\Exception $e) {
            return false;
        }
    }
    
    public function handleWebhook(array $data)
    {
        // معالجة إشعارات webhook من MyFatoorah
        $eventType = $data['EventType'] ?? '';
        $invoiceId = $data['InvoiceId'] ?? null;
        
        // البحث عن محاولة الدفع والطلب
        $paymentAttempt = PaymentAttempt::where('transaction_id', $invoiceId)->first();
        
        if (!$paymentAttempt) {
            return ['success' => false, 'message' => 'محاولة دفع غير موجودة'];
        }
        
        $order = $paymentAttempt->order;
        
        if ($eventType === 'InvoicePaid') {
            // تحديث حالة الطلب
            $order->update(['status' => 'paid']);
            
            // تحديث حالة محاولة الدفع
            $paymentAttempt->update([
                'status' => 'completed',
                'verified_at' => now(),
            ]);
            
            return ['success' => true, 'message' => 'تم تحديث حالة الطلب بنجاح'];
        }
        
        return ['success' => false, 'message' => 'نوع الحدث غير مدعوم'];
    }
}
```


### ب. مسارات الاستجابة المخصصة

```php
// في routes/web.php

// مسارات مخصصة لـ MyFatoorah
Route::get('payment/callback/myfatoorah/success', [PaymentCallbackController::class, 'myfatoorahSuccess'])
    ->name('payment.callback.myfatoorah.success');

Route::get('payment/callback/myfatoorah/cancel', [PaymentCallbackController::class, 'myfatoorahCancel'])
    ->name('payment.callback.myfatoorah.cancel');

Route::post('payment/webhook/myfatoorah', [WebhookController::class, 'handleMyFatoorah'])
    ->name('payment.webhook.myfatoorah')
    ->withoutMiddleware(['csrf']);
```

## 7. قائمة التحقق عند إضافة بوابة جديدة

- [ ] إنشاء فئة تمتد من `BaseGateway`
- [ ] تنفيذ جميع الدوال المطلوبة (processPayment, verifyPayment, handleWebhook)
- [ ] تعريف حقول الإعدادات من خلال `getConfigFields()`
- [ ] إضافة سجل في جدول `payment_methods`
- [ ] إضافة مسارات الاستجابة (success/cancel)
- [ ] إضافة مسار webhook إذا كانت البوابة تدعم ذلك
- [ ] تنفيذ دوال المعالجة في وحدات التحكم
- [ ] اختبار البوابة في وضع الاختبار
- [ ] مراجعة تسجيل المعاملات وتتبع الأخطاء

## 8. الخاتمة

هذا الدليل يوفر إطارًا موحدًا لإضافة وإدارة بوابات الدفع في النظام. باتباع هذه الإرشادات، يمكن بسهولة دمج أي بوابة دفع جديدة مع الحفاظ على تجربة متسقة للمستخدمين والمطورين على حد سواء.
